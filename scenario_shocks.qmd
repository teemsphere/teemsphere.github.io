# Scenario shocks

## Overview
`ems_shock()` with `type = "scenario"` is an intertemporal shock type that specifies heterogeneous shocks at the tuple level as absolute values.
Inputs must cover all pre-aggregation tuples and span the full extent of the variable â€” no partial variable scenario shocks are permitted.
Values are aggregated according to the set mappings in `ems_data()` and then converted to percentage changes internally, making scenario shocks portable across different model aggregations.

```r
ems_shock(var, type = "scenario", input)
```

| Argument | Type | Description |
|----------|------|-------------|
| `var` | Character | Variable name as it appears in the model file |
| `type` | Character | Set to `"scenario"` |
| `input` | Data frame or Character | Data frame or path to a CSV file containing all pre-aggregation tuples, a `Year` column (chronological years), and a `Value` column (absolute values) |

## Using scenario shocks
Scenario shocks differ from custom shocks in a number of respects:

1. Only available for intertemporal models

2. Inputs must contain all *preaggregation* tuples associated with a variable

3. Inputs must span all elements (no partial variable scenario shock)

4. Inputs are denominated in actual values (e.g., million USD)

5. The input dataframe or CSV must contain one column "Year", corresponding to the chronological year for a shock in a specific tuple

There are several applications where it is advantageous to use scenario shock rather than a custom shock. The primary advantage is that scenario shocks allow for seamless changes to model aggregations since the shocks themselves are subject to mappings and aggregation. If we have trajectories available for all tuples within a given variable, a scenario shock will adjust to set mapping inputs in `ems_data()`. The actual values provided do not necessarily need to correspond to realworld values. We could for example use the integer 1 as a base and vary our components according to this base value in the year corresponding to t0.

## Population trajectory example
Here is an example that takes base year population data from the GTAP database (typically not read into the model) and constructs hypothetical pathways for every region in the model. These pathways are valid for any regional aggregation chosen.

Grab population data with `REG` set to "full" to keep regions disaggregated
```r
pop <- ems_data(
  dat_input = "~/dat/GTAP/v11c/flexAgg11c17/gsdfdat.har",
  par_input = "~/dat/GTAP/v11c/flexAgg11c17/gsdfpar.har",
  set_input = "~/dat/GTAP/v11c/flexAgg11c17/gsdfset.har",
  REG = "full",
  TRAD_COMM = "macro_sector",
  ENDW_COMM = "labor_agg"
)$POP
```

Construct a data frame with random growth rates through 2033 using the 2017 base year data
```r
pop$Year <- 2017
regions <- unique(pop$REG)
pop_traj <- expand.grid(
  REG = regions,
  Value = 0,
  Year = c(2018, 2019, 2020, 2021, 2023, 2025, 2027, 2029, 2031, 2033),
  stringsAsFactors = FALSE
)
pop <- rbind(pop, pop_traj)

growth_rates <- data.frame(
  REG = regions,
  growth_rate = runif(length(regions), min = -0.01, max = 0.05)
)

pop <- merge(pop, growth_rates, by = "REG")
base_values <- pop[pop$Year == 2017, c("REG", "Value")]
names(base_values)[2] <- "base_value"
pop <- merge(pop, base_values, by = "REG")

pop$Value[pop$Year > 2017] <-
  pop$base_value[pop$Year > 2017] *
    (1 + pop$growth_rate[pop$Year > 2017])^(pop$Year[pop$Year > 2017] - 2017)
pop$growth_rate <- NULL
pop$base_value <- NULL
pop <- pop[order(pop$REG, pop$Year), ]
pop <- pop[, c("REG", "Year", "Value")]
colnames(pop)[1] <- "REGr"
```

And load as a scenario shock
```r
pop_trajectory <- ems_scenario_shock(
  var = "pop",
  input = pop
)
```

Note that the object "pop" may also be saved as a .csv and loaded directly from storage.
